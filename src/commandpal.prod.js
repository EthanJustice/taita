class CommandPal { constructor(source, options) { this.source = source; this.matchedCommands = { _oldCommands: this.commands, commands: [], changed: function () { if (this._oldCommands != this.commands) { return true } else { return false } }, reset: function () { this._oldCommands = this.commands; this.commands = []; return this.commands }, sort: type => { if (type == 'alphabetical') { this.matchedCommands.commands.sort((a, b) => { if (a.localeCompare(b) > b.localeCompare(a)) { return 1 } else if (a.localeCompare(b) < b.localeCompare(a)) { return -1 } }) } else if (type == 'reverse-alphabetical') { this.matchedCommands.commands.sort((a, b) => { if (a.localeCompare(b) > b.localeCompare(a)) { return -1 } else if (a.localeCompare(b) < b.localeCompare(a)) { return 1 } }) } else if (type == 'rank' || type == 'reverse-rank') { this.matchedCommands.ranks = []; this.matchedCommands.commands.forEach((item, index) => { this.matchedCommands.ranks[index] = {}; this.matchedCommands.ranks[index].name = item }); Object.values(this.commands).forEach(item => { Object.values(this.matchedCommands.ranks).forEach((arrItem, index) => { if (item.name == arrItem.name) { this.matchedCommands.ranks[index].rank = item.rank || 0 } if (item.aliases) { item.aliases.forEach(alias => { if (alias == arrItem.name) { this.matchedCommands.ranks[index].rank = item.rank || 0 } }) } }) }); if (type == 'rank') { this.matchedCommands.ranks.sort((a, b) => parseFloat(b.rank) - parseFloat(a.rank)); } else if (type == 'reverse-rank') { this.matchedCommands.ranks.sort((a, b) => parseFloat(a.rank) - parseFloat(b.rank)); } this.matchedCommands.commands = this.matchedCommands.ranks.map(item => item.name) } else { this._generateError('', 'Invalid sorting pattern.') } } }; this.rankings = { getRankings: (...commands) => { if (commands.length == 0) { this._generateError('', 'No commands specified when calling rankings.getRanking().') } else { return commands.map(command => { return this.commands[command].rank || 0 }) } }, resetRankings: (...commands) => { if (commands.length == 0) { this._generateError('', 'No command specified when calling rankings.resetRanking().') } else { return commands.map(command => { this.commands[command] = Object.assign(this.commands[command], { rank: 0 }); return this.commands[command] }) } }, reset: () => { Object.keys(this.commands).forEach(item => this.commands[item].rank = 0) } }; this.commands = {}; const defaults = { case: false, dev: false, exact: false, ranking: false, sort: false }; this.options = { items: Object.assign({ case: false, dev: false, exact: false, ranking: false, sort: false }, options), reset: function (...items) { if (items.length === 0) { this._generateError('', 'No item specified when calling options.remove().') } else { return items.map(item => { this.items[item] = defaults[item]; return this.items[item] }) } }, update: function (items) { if (!items) { this._generateError('', 'No item(s) specified when calling options.update().') } else { this.items = Object.assign(this.items, items); return this.items } } }; this._fetchCommands() } updateCommand(...args) { if (args.length === 0) { this._generateError('', 'No specified command when calling method updateCommand().') } args.forEach(arg => { this.commands[Object.keys(arg)[0]] = Object.assign(Object.values(arg)[0], this.commands[Object.keys(arg)[0]]) }) } removeCommands(...args) { if (args.length === 0) { this._generateError('', `No specified command when calling method removeCommand().`) } else { args.forEach(arg => { if (this.commands[arg]) { delete this.commands[arg] } else { Object.keys(this.commands).forEach(command => { if (this.commands[command].name == arg) { delete this.commands[command] } else if (this.commands[command].aliases) { this.commands[command].aliases.forEach(alias => { if (alias == arg) { delete this.commands[command] } }) } }) } }) } } _fetchCommands() { if (typeof this.source == 'string' && this.source.endsWith('.json')) { fetch(this.source).then(res => { return res.json() }).then(data => { this.commands = Object.assign(this.commands, data) }).catch(err => { this._generateError(err, `Failed to load commands from source ${this.source}.`) }) } else { this.commands = Object.assign(this.commands, this.source) } } updateCommandList(source) { if (source == this.source) { return false } else { this.source = source; this._fetchCommands() } } listen(value) { this.matchedCommands.reset(); if (this.options.items.case === false) { value = value.toLowerCase() } Object.keys(this.commands).forEach(command => { if (this.commands[command].aliases) { this.commands[command].aliases.forEach((alias, index) => { if (this.options.items.case === false) { if (this.options.items.exact === true) { if (this.commands[command].aliases[index].toLowerCase().startsWith(value)) { this.matchedCommands.commands.push(this.commands[command].aliases[index]) } } else { if (this.commands[command].aliases[index].toLowerCase().includes(value)) { this.matchedCommands.commands.push(this.commands[command].aliases[index]) } } } else { if (this.options.items.exact === true) { if (this.commands[command].aliases[index].startsWith(value)) { this.matchedCommands.commands.push(this.commands[command].aliases[index]) } } else { if (this.commands[command].aliases[index].includes(value)) { this.matchedCommands.commands.push(this.commands[command].aliases[index]) } } } }) } if (this.options.items.case === false) { if (this.options.items.exact === true) { if (this.commands[command].name.toLowerCase().startsWith(value)) { this.matchedCommands.commands.push(this.commands[command].name) } } if (this.commands[command].name.toLowerCase().includes(value)) { this.matchedCommands.commands.push(this.commands[command].name) } } else { if (this.options.items.exact === true) { if (this.commands[command].name.startsWith(value)) { this.matchedCommands.commands.push(this.commands[command].name) } } else { if (this.commands[command].name.includes(value)) { this.matchedCommands.commands.push(this.commands[command].name) } } } }); if (this.options.items.sort) { this.matchedCommands.sort(this.options.items.sort) }; return this.matchedCommands.commands }; execute(command, obj) { let callback; Object.values(this.commands).forEach(item => { if (item.name == command) { if (this.options.items.ranking) { if (!item.rank) { item.rank = 1 } else if (item.rank >= 1) { item.rank += 1 } } callback = item.callback } else if (item.aliases) { item.aliases.forEach(alias => { if (alias == command) { callback = item.callback; if (this.options.items.ranking) { if (!item.rank) { item.rank = 1 } else if (item.rank >= 1) { item.rank += 1 } } } }) } }); if (!obj) { obj = window } obj[callback](command) }; _generateError(error, msg) { console.error(`CommandPal error${this.options.items.dev ? `: ${msg}` : '.'}${error ? `  Error: ${error}` : ''}`) } }